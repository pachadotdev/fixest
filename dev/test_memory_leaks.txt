==52572== Memcheck, a memory error detector
==52572== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==52572== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==52572== Command: /usr/lib/R/bin/exec/R --vanilla -f dev/test_memory_leaks.r
==52572== 

R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> if (!require("devtools")) install.packages("devtools")
Loading required package: devtools
Loading required package: usethis
> devtools::load_all()
â„¹ Loading fixest2
The current project used 'fixest' version 2024.2.22, but the current version is
only 0.11.3. Maybe update the package?
> 
> #----------------------------------------------#
> # Author: Laurent Berge
> # Date creation: Fri Jul 10 09:03:06 2020
> # ~: package sniff tests
> #----------------------------------------------#
> 
> # Not everything is currently covered, but I'll improve it over time
> 
> # Some functions are not trivial to test properly though
> 
> test <- fixest:::test
Registered S3 methods overwritten by 'fixest':
  method                    from   
  print.dsb                 fixest2
  print.fixest              fixest2
  print.fixest_fitstat      fixest2
  print.vec_n_unik          fixest2
  print.list_n_unik         fixest2
  print.osize               fixest2
  summary.fixest.fixef      fixest2
  summary.fixest            fixest2
  summary.fixest_list       fixest2
  summary.fixest_check_conv fixest2
  aggregate.fixest          fixest2
  plot.fixest.fixef         fixest2
  [.fixest_panel            fixest2
  [.fixest_multi            fixest2
  [[.fixest_multi           fixest2
  print.fixest_multi        fixest2
  summary.fixest_multi      fixest2
  as.list.fixest_multi      fixest2
  print.etable_tex          fixest2
  print.etable_df           fixest2
  rep.fixest                fixest2
  rep.fixest_list           fixest2
  nobs.fixest               fixest2
  logLik.fixest             fixest2
  AIC.fixest                fixest2
  BIC.fixest                fixest2
  vcov.fixest               fixest2
  resid.fixest              fixest2
  residuals.fixest          fixest2
  coef.fixest               fixest2
  coefficients.fixest       fixest2
  fitted.fixest             fixest2
  fitted.values.fixest      fixest2
  update.fixest             fixest2
  predict.fixest            fixest2
  confint.fixest            fixest2
  confint.fixest_multi      fixest2
  formula.fixest            fixest2
  model.matrix.fixest       fixest2
  terms.fixest              fixest2
  lag.formula               fixest2
  deviance.fixest           fixest2
  sigma.fixest              fixest2
  weights.fixest            fixest2
  hatvalues.fixest          fixest2
  df.residual.fixest        fixest2
  coef.fixest_multi         fixest2
  coefficients.fixest_multi fixest2
  resid.fixest_multi        fixest2
  residuals.fixest_multi    fixest2
  fixef.fixest              fixest2
  estfun.fixest             fixest2
  bread.fixest              fixest2
> chunk <- fixest:::chunk
> vcovClust <- fixest:::vcovClust
> stvec <- stringmagic::string_vec_alias()
> 
> setFixest_notes(FALSE)
> 
> if (fixest:::is_r_check()) {
+   if (requireNamespace("data.table", quietly = TRUE)) {
+     library(data.table)
+     data.table::setDTthreads(1)
+   }
+   setFixest_nthreads(4)
+ }
> 
> # ESTIMATIONS ----
> 
> ## Main ----
> 
> chunk("ESTIMATION")
ESTIMATION

> 
> set.seed(0)
> 
> base <- iris
> names(base) <- c("y", "x1", "x2", "x3", "species")
> base$fe_2 <- rep(1:5, 30)
> base$fe_3 <- sample(15, 150, TRUE)
> base$constant <- 5
> base$y_int <- as.integer(base$y)
> base$w <- as.vector(unclass(base$species) - 0.95)
> base$offset_value <- unclass(base$species) - 0.95
> base$y_01 <- 1 * ((scale(base$x1) + rnorm(150)) > 0)
> # what follows to avoid removal of fixed-effects (logit is pain in the neck)
> base$y_01[1:5 + rep(c(0, 50, 100), each = 5)] <- 1
> base$y_01[6:10 + rep(c(0, 50, 100), each = 5)] <- 0
> # We enforce the removal of observations
> base$y_int_null <- base$y_int
> base$y_int_null[base$fe_3 %in% 1:5] <- 0
> 
> for (model in c("ols", "pois", "logit", "negbin", "Gamma")) {
+   cat("Model: ", format(model, width = 6), sep = "")
+   for (use_weights in c(FALSE, TRUE)) {
+     my_weight <- NULL
+     if (use_weights) my_weight <- base$w
+ 
+     for (use_offset in c(FALSE, TRUE)) {
+       my_offset <- NULL
+       if (use_offset) my_offset <- base$offset_value
+ 
+       for (id_fe in 0:9) {
+         cat(".")
+ 
+         tol <- switch(model,
+           "negbin" = 1e-2,
+           "logit" = 3e-5,
+           1e-5
+         )
+ 
+         # Setting up the formula to accommodate FEs
+         if (id_fe == 0) {
+           fml_fixest <- fml_stats <- y ~ x1
+         } else if (id_fe == 1) {
+           fml_fixest <- y ~ x1 | species
+           fml_stats <- y ~ x1 + factor(species)
+         } else if (id_fe == 2) {
+           fml_fixest <- y ~ x1 | species + fe_2
+           fml_stats <- y ~ x1 + factor(species) + factor(fe_2)
+         } else if (id_fe == 3) {
+           # varying slope
+           fml_fixest <- y ~ x1 | species[[x2]]
+           fml_stats <- y ~ x1 + x2:species
+         } else if (id_fe == 4) {
+           # varying slope -- 1 VS, 1 FE
+           fml_fixest <- y ~ x1 | species[[x2]] + fe_2
+           fml_stats <- y ~ x1 + x2:species + factor(fe_2)
+         } else if (id_fe == 5) {
+           # varying slope -- 2 VS
+           fml_fixest <- y ~ x1 | species[x2]
+           fml_stats <- y ~ x1 + x2:species + species
+         } else if (id_fe == 6) {
+           # varying slope -- 2 VS bis
+           fml_fixest <- y ~ x1 | species[[x2]] + fe_2[[x3]]
+           fml_stats <- y ~ x1 + x2:species + x3:factor(fe_2)
+         } else if (id_fe == 7) {
+           # Combined clusters
+           fml_fixest <- y ~ x1 + x2 | species^fe_2
+           fml_stats <- y ~ x1 + x2 + paste(species, fe_2)
+         } else if (id_fe == 8) {
+           fml_fixest <- y ~ x1 | species[x2] + fe_2[x3] + fe_3
+           fml_stats <- y ~ x1 + species + i(species, x2) + factor(fe_2) + i(fe_2, x3) + factor(fe_3)
+         } else if (id_fe == 9) {
+           fml_fixest <- y ~ x1 | species + fe_2[x2, x3] + fe_3
+           fml_stats <- y ~ x1 + species + factor(fe_2) + i(fe_2, x2) + i(fe_2, x3) + factor(fe_3)
+         }
+ 
+         # ad hoc modifications of the formula
+         if (model == "logit") {
+           fml_fixest <- xpd(y_01 ~ ..rhs, ..rhs = fml_fixest[[3]])
+           fml_stats <- xpd(y_01 ~ ..rhs, ..rhs = fml_stats[[3]])
+ 
+           # The estimations are OK, conv differences out of my control
+           if (id_fe %in% 8:9) tol <- 0.5
+         } else if (model == "pois") {
+           fml_fixest <- xpd(y_int_null ~ ..rhs, ..rhs = fml_fixest[[3]])
+           fml_stats <- xpd(y_int_null ~ ..rhs, ..rhs = fml_stats[[3]])
+         } else if (model %in% c("negbin", "Gamma")) {
+           fml_fixest <- xpd(y_int ~ ..rhs, ..rhs = fml_fixest[[3]])
+           fml_stats <- xpd(y_int ~ ..rhs, ..rhs = fml_stats[[3]])
+         }
+ 
+         adj <- 1
+         if (model == "ols") {
+           res <- feols(fml_fixest, base, weights = my_weight, offset = my_offset)
+           res_bis <- lm(fml_stats, base, weights = my_weight, offset = my_offset)
+         } else if (model %in% c("pois", "logit", "Gamma")) {
+           adj <- 0
+           if (model == "Gamma" && use_offset) next
+ 
+           my_family <- switch(model,
+             pois = poisson(),
+             logit = binomial(),
+             Gamma = Gamma()
+           )
+ 
+           res <- feglm(fml_fixest, base, family = my_family, weights = my_weight, offset = my_offset)
+ 
+           if (!is.null(res$obs_selection$obsRemoved)) {
+             qui <- res$obs_selection$obsRemoved
+ 
+             # I MUST do that.... => subset does not work...
+             base_tmp <- base[qui, ]
+             base_tmp$my_offset <- my_offset[qui]
+             base_tmp$my_weight <- my_weight[qui]
+             res_bis <- glm(fml_stats, base_tmp, family = my_family, weights = my_weight, offset = my_offset)
+           } else {
+             res_bis <- glm(fml_stats, data = base, family = my_family, weights = my_weight, offset = my_offset)
+           }
+         } else if (model == "negbin") {
+           # no offset in glm.nb + no VS in fenegbin + no weights in fenegbin
+           if (use_weights || use_offset || id_fe > 2) next
+ 
+           res <- fenegbin(fml_fixest, base, notes = FALSE)
+           res_bis <- MASS::glm.nb(fml_stats, base)
+         }
+ 
+         test(coef(res)["x1"], coef(res_bis)["x1"], "~", tol)
+         test(se(res, se = "st", ssc = ssc(adj = adj))["x1"], se(res_bis)["x1"], "~", tol)
+         test(pvalue(res, se = "st", ssc = ssc(adj = adj))["x1"], pvalue(res_bis)["x1"], "~", tol * 10**(model == "negbin"))
+         # cat("Model: ", model, ", FE: ", id_fe, ", weight: ", use_weights,  ", offset: ", use_offset, "\n", sep="")
+       }
+       cat("|")
+     }
+   }
+   cat("\n")
+ }
Model: ols   ..........|..........|.Error in test(coef(res)["x1"], coef(res_bis)["x1"], "~", tol) : 
  Difference > tol: Max abs. diff: 1.00012731313248 (in position 1)
Execution halted
==52572== 
==52572== HEAP SUMMARY:
==52572==     in use at exit: 194,615,838 bytes in 32,759 blocks
==52572==   total heap usage: 414,667 allocs, 381,908 frees, 926,127,146 bytes allocated
==52572== 
==52572== LEAK SUMMARY:
==52572==    definitely lost: 0 bytes in 0 blocks
==52572==    indirectly lost: 0 bytes in 0 blocks
==52572==      possibly lost: 1,008 bytes in 3 blocks
==52572==    still reachable: 194,614,830 bytes in 32,756 blocks
==52572==                       of which reachable via heuristic:
==52572==                         newarray           : 4,264 bytes in 1 blocks
==52572==         suppressed: 0 bytes in 0 blocks
==52572== Rerun with --leak-check=full to see details of leaked memory
==52572== 
==52572== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
