% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{coeftable.fixest}
\alias{coeftable.fixest}
\alias{se.fixest}
\alias{tstat.fixest}
\alias{pvalue.fixest}
\title{Obtain various statistics from an estimation}
\usage{
\method{coeftable}{fixest}(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  list = FALSE,
  ...
)

\method{se}{fixest}(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)

\method{tstat}{fixest}(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)

\method{pvalue}{fixest}(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)
}
\arguments{
\item{object}{A `fixest` object. For example an estimation obtained from [`feols`].}

\item{cluster}{Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over `var1` and `var2` contained in the data.frame `base` used for the estimation. All the following `cluster` arguments are valid and do the same thing: `cluster = base[, c("var1, "var2")]`, `cluster = c("var1, "var2")`, `cluster = ~var1+var2`. If the two variables were used as clusters in the estimation, you could further use `cluster = 1:2` or leave it blank with `se = "twoway"` (assuming `var1` \[resp. `var2`\] was the 1st \[resp. 2nd\] cluster).}

\item{list}{Logical, default is `FALSE`. If `TRUE`, then a nested list is returned, the first layer is accessed with the coefficients names; the second layer with the following values: `coef`, `se`, `tstat`, `pvalue`. Note that the variable `"(Intercept)"` is renamed into `"constant"`.}

\item{...}{Other arguments to be passed to [`summary.fixest`].}
}
\value{
Returns a table of coefficients, with in rows the variables and four columns: the estimate, the standard-error, the t-statistic and the p-value.

If `list = TRUE` then a nested list is returned, the first layer is accessed with the coefficients names; the second layer with the following values: `coef`, `se`, `tstat`, `pvalue`. For example, with `res = coeftable(est, list = TRUE)` you can access the SE of the coefficient `x1` with `res$x1$se`; and its coefficient with `res$x1$coef`, etc.
}
\description{
Set of functions to directly extract some commonly used statistics, like the p-value or the table of coefficients, from estimations. This was first implemented for `fixest` estimations, but has some support for other models.
}
\details{
This set of tiny functions is primarily constructed for `fixest` estimations.
}
\section{Functions}{
\itemize{
\item \code{se(fixest)}: Extracts the standard-error of an estimation

\item \code{tstat(fixest)}: Extracts the t-statistics of an estimation

\item \code{pvalue(fixest)}: Extracts the p-value of an estimation

}}
\examples{

# Some data and estimation
data(trade)
est <- fepois(Euros ~ log(dist_km) | Origin^Product + Year, trade)

#
# Coeftable/se/tstat/pvalue
#

# Default is clustering along Origin^Product
coeftable(est)
se(est)
tstat(est)
pvalue(est)

# Now with two-way clustered standard-errors
#  and using coeftable()

coeftable(est, cluster = ~ Origin + Product)
se(est, cluster = ~ Origin + Product)
pvalue(est, cluster = ~ Origin + Product)
tstat(est, cluster = ~ Origin + Product)

# Or you can cluster only once:
est_sum <- summary(est, cluster = ~ Origin + Product)
coeftable(est_sum)
se(est_sum)
tstat(est_sum)
pvalue(est_sum)

# You can use the arguments keep, drop, order
# to rearrange the results

base <- iris
names(base) <- c("y", "x1", "x2", "x3", "species")

est_iv <- feols(y ~ x1 | x2 ~ x3, base)

tstat(est_iv, keep = "x1")
coeftable(est_iv, keep = "x1|Int")

coeftable(est_iv, order = "!Int")

#
# Using lists
#

# Returning the coefficients table as a list can be useful for quick
# reference in markdown documents.
# Note that the "(Intercept)" is renamed into "constant"

res <- coeftable(est_iv, list = TRUE)

# coefficient of the constant:
res$constant$coef

# pvalue of x1
res$x1$pvalue

}
